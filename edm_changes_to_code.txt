AdjustStorage.c
Aggregate.c
AggregateRadiation.c
Bagnold.c
CalcAerodynamic.c
CalcAvailableWater.c
CalcDistance.c
CalcEffectiveKh.c
CalcKhDry.c
CalcSafetyFactor.c
51,53c51
< 
<     if(SoilDepth<=0.0) SoilDepth=0.001;
< 
---
>     
55d52
<     if(M>=1.0) M=0.99;
CalcSnowAlbedo.c
CalcSolar.c
CalcTotalWater.c
CalcTransmissivity.c
CalcWeights.c
Calendar.c
CanopyResistance.c
ChannelState.c
CheckOut.c
CutBankGeometry.c
DHSVMChannel.c
132,145d131
< /* -------------------------------------------------------------
<    InitSedimentDump
<    ------------------------------------------------------------- */
< void InitSedimentDump(CHANNEL * channel, char *DumpPath)
< {
<   char buffer[NAMESIZE];
< 
<   if (channel->streams != NULL) {
<     sprintf(buffer, "%sSediment.Flow", DumpPath);
<     OpenFile(&(channel->sedimentout), buffer, "w", TRUE);
<     sprintf(buffer, "%sSedimentflow.Only", DumpPath);
<     OpenFile(&(channel->sedimentflowout), buffer, "w", TRUE);
<   }
< }
Desorption.c
Draw.c
EvalExponentIntegral.c
EvapoTranspiration.c
ExecDump.c
FileIOBin.c
FileIONetCDF.c
Files.c
FinalMassBalance.c
FindValue.c
49c49
<     if(MASSITER == 0) /*EDM - changed to be "0" for specifying the mean */
---
>     if(MASSITER == 1)
55c55
<      if(MASSITER == 0) /*EDM - changed to be "0" for specifying the mean */
---
>      if(MASSITER == 1)
61c61
<      if(MASSITER == 0) /*EDM - changed to be "0" for specifying the mean */
---
>      if(MASSITER == 1)
GetInit.c
GetMetData.c
InArea.c
InitAggregated.c
InitArray.c
InitConstants.c
InitDump.c
InitFileIO.c
InitFineMaps.c
InitInterpolationWeights.c
InitMetMaps.c
InitMetSources.c
InitModelState.c
InitNetwork.c
InitNewMonth.c
InitParameters.c
InitSedTables.c
InitSnowMap.c
InitTables.c
InitTerrainMaps.c
InitUnitHydrograph.c
InitXGraphics.c
InterceptionStorage.c
IsStationLocation.c
LapseT.c
LookupTable.c
MainDHSVM.c
62d61
<   int flag;
76d74
<   char buffer[32];
220,223d217
<   if (Options.Sediment) {
<     InitSedimentDump(&ChannelData, Dump.Path);
<   }
< 
266d259
<     printf("\n initializing channel sediment\n");
269d261
<     printf("\n done...\n");
374,376d365
<     /* set sediment inflows to zero - they are incremented elsewhere */
<     if(Options.Sediment) InitChannelSedInflow(ChannelData.streams);
< 
384d372
<     /* Sediment Routing in Channel and output to sediment files */
386,393c374,375
<       RouteChannelSediment(ChannelData.streams, ChannelData.roads, Time, &Dump);
<       SPrintDate(&(Time.Current), buffer);
<       flag = IsEqualTime(&(Time.Current), &(Time.Start));
<       channel_save_sed_outflow_text(buffer, ChannelData.streams,
< 			      ChannelData.sedimentout,
< 			      ChannelData.sedimentflowout, flag);
< 
<       /* OutputChannelSediment(ChannelData.streams, Time, &Dump); */
---
>       // RouteChannelSediment(ChannelData.streams, ChannelData.roads, Time, &Dump);
>     //   OutputChannelSediment(ChannelData.streams, Time, &Dump);
441,450d422
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
MainMWM.c
9c9
<  * Last Change: Fri Jun 13 10:41:51 2003 by Ed Maurer <edm@u.washington.edu>
---
>  * Last Change:  
36c36
< float Bagnold(float DS,TIMESTRUCT * Time, float, float, float, float);
---
> 
40c40,41
< void RouteDebrisFlow(float *SedimentToChannel, int prevy, int prevx, float SlopeAspect, CHANNEL *ChannelData, MAPSIZE *Map); 
---
> void RouteDebrisFlow(float *SedimentToChannel, int prevy, int prevx, float SlopeAspect, 
> 		     CHANNEL *ChannelData, MAPSIZE *Map); 
42,43d42
< void InitChannelSedInflow(Channel * Head);
< void DistributeSedimentDiams(float SedDiam[NSEDSIZES]);
46d44
< void Alloc_Chan_Sed_Mem(float ** DummyVar);
69d66
<   int massitertemp;       /* if massiter is 0, sets the counter to 1 here */
81d77
<   float *SedDiams, *SedDist;
110,116c106
<   if (!(SegmentSediment = (float *)calloc(MaxStreamID, sizeof(float ))))
<     ReportError("MainSEM", 1);
< 
<   if (!(SedDiams = (float *)calloc(NSEDSIZES, sizeof(float))))
<     ReportError("MainSEM", 1);
< 
<   if (!(SedDist = (float *)calloc(NSEDSIZES, sizeof(float))))
---
>   if (!(SegmentSediment = (float *)calloc(MaxStreamID, sizeof(int))))
119c109
<   if (!(InitialSegmentSediment = (float *)calloc(NSEDSIZES, sizeof(float ))))
---
>    if (!(InitialSegmentSediment = (float *)calloc(MaxStreamID, sizeof(int))))
154c144
<   update_sediment_array(ChannelData->streams, InitialSegmentSediment);
---
>   initialize_sediment_array(ChannelData->streams, InitialSegmentSediment);
159,164c149
< 
<   /* sloppy fix for when MASSITER=0 -- this only needs to be checked once */
<   if(MASSITER==0) massitertemp=1;
<   else massitertemp=MASSITER;
< 
<   for(iter=0; iter < massitertemp; iter++) {
---
>   for(iter=0; iter < MASSITER; iter++) {
201d185
< 		  /* check if fine pixel fails */
208c192
< 		      /* Update sediment depth. All sediment leaves failed fine pixel */
---
> 		      /* Update sediment depth. */
250c234
< 		      /* Update sediment depth. All sedminet leaves failed fine pixel */
---
> 		      /* Update sediment depth. */
297,299c281
< 		    /* TotalVolume at this point is a depth in m over one fine
< 		       map grid cell - convert to m3 */
< 		    SedimentToChannel = TotalVolume*(Map->DMASS*Map->DMASS)/(float) cells;
---
> 		    SedimentToChannel = TotalVolume/cells;
333,345c315,323
< 	  (*FineMap)[i][j].probability += (float) failure[i][j];
< 	  
< 	  /* Record cumulative sediment volume. */
< 	  SedThickness[i][j] += (*FineMap)[i][j].sediment;
< 	  
< 	  /* Reset sediment thickness for each iteration; otherwise there is 
< 	     a decreasing probability of failure for subsequent iterations. */
< 	  /* If not in stochastic mode, then allow a history of past failures
< 	     and do not reset sediment depth */
< 	  if(massitertemp>1) {
< 	    (*FineMap)[i][j].sediment = InitialSediment[i][j];
< 	    failure[i][j] = 0;
< 	  }
---
> 	(*FineMap)[i][j].probability += (float) failure[i][j];
> 
> 	/* Record cumulative sediment volume. */
> 	SedThickness[i][j] += (*FineMap)[i][j].sediment;
> 
> 	/* Reset sediment thickness for each iteration; otherwise there is 
> 	   a decreasing probability of failure for subsequent iterations. */
> 	(*FineMap)[i][j].sediment = InitialSediment[i][j];
> 	failure[i][j] = 0;
353c331
< 
---
>    
356c334
< 
---
>     
384,385c362,363
< 	  (*FineMap)[i][j].probability /= (float)massitertemp;
< 	  (*FineMap)[i][j].sediment = SedThickness[i][j]/(float)massitertemp;
---
> 	  (*FineMap)[i][j].probability /= (float)MASSITER;
> 	  (*FineMap)[i][j].sediment = SedThickness[i][j]/(float)MASSITER;
400d377
<   /*average sediment delivery to each stream segment***************/
402,405c379,380
<     SegmentSediment[i] /= (float)massitertemp;
<     if(SegmentSediment[i] < 0.0) SegmentSediment[i]=0.0;
<     /*    fprintf(stderr, "segment %d: segmentsediment = %f\n", i, 
< 	  SegmentSediment[i]-InitialSegmentSediment[i]); */
---
>     SegmentSediment[i] /= (float)MASSITER;
>     //    fprintf(stderr, "segment %d: segmentsediment = %f\n", i, SegmentSediment[i]-InitialSegmentSediment[i]);
408,411d382
<   /* Take new sediment inflow and distribute it by representative diameters*/
<   /* and convert to mass */
<   sed_vol_to_distrib_mass(ChannelData->streams, SegmentSediment);
<   /* back to map analysis******************************************/
547,556d517
<   Alloc_Chan_Sed_Mem
< *****************************************************************************/
< void Alloc_Chan_Sed_Mem(float ** DummyVar)
< {
<   printf("in sub\n");
<   if (!(*DummyVar = (float *) calloc(NSEDSIZES, sizeof(float))))
<     ReportError("sed_chan_alloc", 1);
<   printf("did it\n");
< }
< /*****************************************************************************
559,560c520,521
<   Assign initial colluvium mass to each unique channel ID (amount
<   of storage, kg)
---
>   Assign initial colluvium volumes to each unique channel ID (amount
>   of storage (m3))
565,569c526
<   int i;
<   float InitialDepth = 0.010; /* initial depth of sediment in the channel, m */
<   float bulkporosity, initvol;
< 
<   bulkporosity = 0.245+0.14*pow(DEBRISd50,-0.21); /* Komura, 1961 relation */
---
>   float InitialDepth = 0.25;
574,578c531
<     initvol = Current->length * InitialDepth * Current->class->width;
<     for(i=0;i<NSEDSIZES;i++) {
<       Current->sediment.mass[i] = 
< 	initvol*(1-bulkporosity)*((float) PARTDENSITY)*(1/((float) NSEDSIZES));
<     }
---
>     Current->sediment = Current->length * InitialDepth * Current->class->width;
581,583d533
< }
< /*****************************************************************************
<   InitChannelSedInflow
585,599d534
<   Assign initial colluvium mass to each unique channel ID (amount
<   of storage, kg)
< *****************************************************************************/
< void InitChannelSedInflow(Channel * Head)
< {
<   Channel *Current = NULL;
<   int i;
< 
<   Current = Head;
<   while (Current) {
<     for(i=0;i<NSEDSIZES;i++) {
<       Current->sediment.inflow[i] = 0.0;
<     }
<     Current = Current->next;
<   }
601,602d535
< /*****************************************************************************
<   DistributeSedimentDiams()
604,630d536
<   For new lateral sediment inflow, Find the particle diameters for each portion
<   Assumes a lognormal distribution
< *****************************************************************************/
< void DistributeSedimentDiams(float SedDiam[NSEDSIZES])
< {
<   /* to be consistent with FindValue, use the Tukey (1960) approx to normal
<      CDF -- y is probability, function returns Z(y) */
< #ifndef NORMALDIST
< #define NORMALDIST(mean, stdev, y) (4.91 * stdev * (pow(y,.14) - pow(( 1 - y ),.14)) + mean )
< #endif
< 
<   int i;
<   float mn,std,z;
<   float pctfiner;
< 
<   /* slope of the lognormal curve, log(d) on y-axis, Z on x-axis, is stdev */
<   mn = log10(DEBRISd50);
<   std = log10(DEBRISd90)-log10(DEBRISd50)/(NORMALDIST(0,1,0.9)-NORMALDIST(0,1,0.5));
< 
<   pctfiner = 1.0/(2.0*NSEDSIZES); /* midpoint of finest interval */
< 
<   for(i=0;i<NSEDSIZES;i++) {
<     z = NORMALDIST(mn,std,pctfiner);
<     SedDiam[i] = pow(10,mn+std*z);
<     pctfiner += 1.0/NSEDSIZES;
<   }
< }
640d545
<   int i;
652,654c557
<     fprintf(fo, "%d\t", Current->id);
<     for(i=0;i<NSEDSIZES;i++) fprintf(fo, "%.3f\t", Current->sediment.mass[i]);
<     fprintf(fo, "\n");
---
>     fprintf(fo, "%d\t%f\n", Current->id, Current->sediment);
664,667c567,569
<   Read in DHSVM sediment mass and inflows for each channel segment, and 
<   route sediment downstream. Sorts by particle size, transports finer material
<   first, as done by Williams (1980).
< 
---
>   Read in DHSVM discharge volumes for each channel segment, and route sediment 
>   downstream.
> .
672,729c574,575
<   float DS;
<   float TotalCapacity, CapacityUsed, sumoutflow;
<   float SedDiam[NSEDSIZES];
<   int i;
<   int order;
<   int order_count;
< 
<   /* For each of the sediment diameters, calculate the mass balance */
<   DistributeSedimentDiams(SedDiam); /* find diameter for each portion */
< 
<   /* the next 5 lines are from channel_route_network - used to order streams */
<   for (order = 1;; order += 1) {
<     order_count = 0;
<     Current = Head;
< 
<     while (Current != NULL) {
<       if (Current->order == order) {
< 
< 	sumoutflow = 0.0;
< 	CapacityUsed = 0.0;
< 	Current->outlet->sediment.totalmass=0;
< 	/* current particle size -- convert to m */
< 	/*DO NOT USE BAGNOLD's EQ. FOR D<0.015 mm - this is wash load anyway*/
< 	for(i=0;i<NSEDSIZES;i++) {
< 
< 	  DS = SedDiam[i]*((float) MMTOM);
< 	  /* TotalCapacity is in kg/s */
< 	  TotalCapacity = Bagnold(DS,&Time,Current->outflow,Current->class->width,
< 				  Current->class->friction,Current->slope);
< 	  TotalCapacity -= CapacityUsed; /* Avoid mult use of avail streampower */
< 	  if(TotalCapacity<=0) TotalCapacity=0.0;
< 
< 	  /*	  if(Current->id == 751 || Current->id == 1267)
< 	    printf("id %d size %d mass %.2f TotalCapacity=%.2f upstrin %.2f
< 	    debrisin %.2f overlandin %.2f  \n",Current->id,
< 	    i,Current->sediment.mass[i],TotalCapacity,Current->sediment.inflow[i],Current->sediment.debrisinflow[i],Current->sediment.overlandinflow[i]); */
< 
< 	  Current->sediment.inflow[i] += Current->sediment.debrisinflow[i] + Current->sediment.overlandinflow[i];
< 
< 	  /* per Wicks and Bathurst 1996, finer than 0.062 mm is wash load */
< 	  if(SedDiam[i] < 0.062) {
< 	    Current->sediment.outflow[i] = Current->sediment.inflow[i];
< 	  }
< 	  else {
< 	    Current->sediment.mass[i] += Current->sediment.inflow[i];
< 	    
< 	    if(TotalCapacity*Time.Dt >= Current->sediment.mass[i]) {
< 	      Current->sediment.outflow[i] = Current->sediment.mass[i];
< 	      CapacityUsed += Current->sediment.mass[i]/((float) Time.Dt);
< 	      Current->sediment.mass[i] = 0;
< 	    }
< 	    else {
< 	      Current->sediment.outflow[i] = TotalCapacity*Time.Dt;
< 	      CapacityUsed += TotalCapacity;
< 	      Current->sediment.mass[i] -=  TotalCapacity*Time.Dt;
< 	    }
< 	    Current->sediment.totalmass += Current->sediment.mass[i];
< 	  }
---
>   char buffer[20], FileName[100];
>   FILE *fo;
731,741c577,578
< 	  /*	  if(Current->id == 751)
< 	    printf("id %d size %d TotalCapacity=%.2f Q %.2f in %.2f out %.2f
< 	    CapacityUsed=%.2f
< 	    mass=%.2f\n",Current->id,i,TotalCapacity,Current->outflow,Current->sediment.inflow[i],Current->sediment.outflow[i], CapacityUsed,Current->sediment.mass[i]); */
< 
< 	  sumoutflow += Current->sediment.outflow[i];
< 
< 	  /* pass the sediment mass outflow to the next downstream reach */
< 	  if(Current->outlet != NULL)
< 	    Current->outlet->sediment.inflow[i] += Current->sediment.outflow[i];
< 	}
---
>   SPrintDate(&(Time.Current), buffer);
>   sprintf(FileName, "%s/Channel.sediment.%s.asc", Dump->Path, buffer);
743,755c580,587
< 	/* calculate outflow concentration in mg/l */
< 	Current->sediment.outflowconc = 
< 	  1000.0*sumoutflow/(Current->outflow);
< 
< 	/*	if(Current->id == 257) printf("id %d outc=
< 		%.2f\n",Current->id,Current->sediment.outflowconc); */
< 	/* the next 7 lines are from channel_route_network -- closes the loop above */
< 	order_count += 1;
<       }
<       Current = Current->next;
<     }
<     if (order_count == 0)
<       break;
---
>   if((fo=fopen(FileName,"w")) == NULL)
>     ReportError("OutputChannelSediment", 3);
>   
>   /* Assign the storages to the correct IDs */
>   Current = Head;
>   while (Current) {
>     fprintf(fo, "%d\t%f\n", Current->id, Current->sediment);
>     Current = Current->next;
757c589
< }
---
>   fclose(fo);
758a591
> } 
MakeLocalMetData.c
MassBalance.c
MassEnergyBalance.c
MassRelease.c
MaxRoadInfiltration.c
NoEvap.c
RadiationBalance.c
ReadMetRecord.c
ReadRadarMap.c
ReportError.c
ResetAggregate.c
RootBrent.c
Round.c
RouteSubSurface.c
RouteSurface.c
178,184c178
< 	  slope = TopoMap[y][x].Slope; /*large grid cell slope.*/
<           if (slope == 0) slope=0.0001;
< 	  else if (slope < 0) {
< 	    printf("negative slope in RouteSurface.c\n");
< 	    exit(0);
< 	  }
< 
---
> 	  slope = TopoMap[y][x].Slope;
SatVaporPressure.c
SensibleHeatFlux.c
SeparateRadiation.c
SizeOfNT.c
SlopeAspect.c
394d393
<   float elevsink=0.0;
415,428d413
< /* added to remove sinks. Will be removed when this becomes a preprocessing step */
<  
<      if(celev < neighbor_elev[0] && celev < neighbor_elev[1] && celev < neighbor_elev[2] && celev < neighbor_elev[3]){
<       elevsink=neighbor_elev[0];
<       for (n = 1; n < NDIRS; n++) {
<           if (neighbor_elev[n] < elevsink && neighbor_elev[n] != OUTSIDEBASIN)
<                elevsink= neighbor_elev[n];
<       }
<       celev=elevsink;
<      }
< /* end of added text */
< 
< /*changed to reflect that currently DHSVM can only be run in 4 directions */
< 
432,434c417,419
< /*    if(n==0 || n==2 || n==4 || n==6) */
< /*      temp_slope[n] = (atan((celev - neighbor_elev[n]) / length_diagonal)) * DEGPRAD; */
<     if(n==1 || n==3)
---
>     if(n==0 || n==2 || n==4 || n==6)
>       temp_slope[n] = (atan((celev - neighbor_elev[n]) / length_diagonal)) * DEGPRAD;
>     else if(n==1 || n==5)
SnowInterception.c
SnowMelt.c
SnowPackEnergyBalance.c
SoilEvaporation.c
StabilityCorrection.c
StoreModelState.c
SurfaceEnergyBalance.c
UnsaturatedFlow.c
VarID.c
WaterTableDepth.c
channel.c
20d19
< #include "constants.h"
273,274c272,275
<   for (; head != NULL; head = head->next) 
<     InitialSegmentSediment[head->id] += head->sediment.tempvol; 
---
>   for (; head != NULL; head = head->next) {
>     InitialSegmentSediment[head->id] += head->sediment;
>   }
> 
282,293d282
<   for (; head != NULL; head = head->next)
<     head->sediment.tempvol = InitialSegmentSediment[head->id];
< }
< /* -------------------------------------------------------------
<    sed_vol_to_distrib_mass
<    ------------------------------------------------------------- */
<   /* sediment volume inflow distribute by sediment size, convert to mass */
< void sed_vol_to_distrib_mass(Channel * head, float *volumearray)
< {
<   int i;
<   float bulkporosity;
<   bulkporosity = 0.245+0.14*pow(DEBRISd50,-0.21); /* Komura, 1961 relation */
295,298c284
<     for(i=0;i<NSEDSIZES;i++) {
<       head->sediment.debrisinflow[i] = 
< 	volumearray[head->id]*(1-bulkporosity)*PARTDENSITY*(1/(float)NSEDSIZES);
<     }
---
>     head->sediment = InitialSegmentSediment[head->id];
299a286
> 
300a288,289
> 
> 
831,895d819
< 
< /* -------------------------------------------------------------
<    channel_save_sed_outflow_text
<    Saves the channel sediment outflow using a text string as the time field
<    ------------------------------------------------------------- */
< int
< channel_save_sed_outflow_text(char *tstring, Channel * net, FILE * out,
< 			  FILE * out2, int flag)
< {
<   int err = 0;
< 
<   /* print header line first time through */
<   if (flag == 1) {
<     fprintf(out2, "DATE ");
<     for (; net != NULL; net = net->next) {
<       if (net->record)
< 	fprintf(out2, "%s ", net->record_name);
<     }
<     fprintf(out2, "\n");
<   }
< 
<   if (fprintf(out2, "%15s ", tstring) == EOF) {
<     error_handler(ERRHDL_ERROR,
< 		  "channel_save_outflow: write error:%s", strerror(errno));
<     err++;
<   }
< 
<   for (; net != NULL; net = net->next) {
<     if (net->record) {
<       if (fprintf(out, "%15s %10d %12.5g %12.5g",
< 		  tstring, net->id, net->sediment.totalmass, net->sediment.outflowconc) == EOF) {
< 	error_handler(ERRHDL_ERROR,
< 		      "channel_save_sed_outflow: write error:%s", strerror(errno));
< 	err++;
<       }
<       if (fprintf(out2, "%12.5g ", net->sediment.outflowconc) == EOF) {
< 	error_handler(ERRHDL_ERROR,
< 		      "channel_save_outflow: write error:%s", strerror(errno));
< 	err++;
<       }
<       if (net->record_name != NULL) {
< 	if (fprintf(out, "   \"%s\"\n", net->record_name) == EOF) {
< 	  error_handler(ERRHDL_ERROR,
< 			"channel_save_outflow: write error:%s",
< 			strerror(errno));
< 	  err++;
< 	}
< 
<       }
<       else {
< 	if (fprintf(out, "\n") == EOF) {
< 	  error_handler(ERRHDL_ERROR,
< 			"channel_save_outflow: write error:%s",
< 			strerror(errno));
< 	  err++;
< 	}
<       }
<     }
<   }
<   fprintf(out2, "\n");
< 
<   return (err);
< }
< 
< 
channel_grid.c
64c64
<     CurrentSeg->sediment.tempvol += *SedimentToChannel;
---
>     CurrentSeg->sediment += *SedimentToChannel;
162,163c162,163
<     *SedimentToChannel += CurrPtr->sediment.tempvol;
<     CurrPtr->sediment.tempvol = 0.0;
---
>     *SedimentToChannel += CurrPtr->sediment;
>     CurrPtr->sediment = 0.0;
167,168c167,168
<     *SedimentToChannel += CurrPtr->sediment.tempvol;
<     CurrPtr->sediment.tempvol = 0.;
---
>     *SedimentToChannel += CurrPtr->sediment;
>     CurrPtr->sediment = 0.;
170,171c170,171
<       NextPtr->sediment.tempvol += *SedimentToChannel/2.;
<       CurrPtr->sediment.tempvol = *SedimentToChannel/2.;
---
>       NextPtr->sediment += *SedimentToChannel/2.;
>       CurrPtr->sediment = *SedimentToChannel/2.;
175c175
<       NextPtr->sediment.tempvol += *SedimentToChannel;
---
>       NextPtr->sediment += *SedimentToChannel;
798,801d797
< 
< 
< 
< 
equal.c
errorhandler.c
globals.c
tableio.c
